USEFUL WILDCARDS
* Matches any characters
? Matches any single character
[characters] Matches any character that is a member of the set characters
[!characters] Matches any character that is not a member of the set characters
	[:alnum:] Alphanumeric characters
	[:alpha:] Alphabetic characters
	[:digit:] Numerals
	[:lower:] Matches any lowercase letter
	[:upper:] Matches any uppercase letter

	for example [[:alnum:]] matches any alphanumeric character


USEFUL COMMANDS
command -options --other-options arguments
	date - prints the current date
	cal - prints the calendar for the current month
	df - displays free space available on disk drives
	free - displays the amount of free memory
	exit - quits the shell and closes the emulator program
	cd - - yes include the extra dash. Moves to the previous working directory.
	file - Determine file type (ASCII text, UTF-8 text, etc.)
	less - view file contents. I prefer vim -M to open vim in readonly mode.
	cp files dir - copy files 
		-a archive: copy the permissions and ownership of files as well
		-i interactive: prompt before overwriting a file
		-r recursive: obv.
		-u update: only copy files that are newer or don't exist to the new location
		-v verbose: be explicit about what's happening
	mv files path - moves files or directories to the desired location
		-i interactive:
		-u update
		-v verbose
	rm files - deletes the selected files
		-i interactive: see a common theme here?
		-r recursive: delete all subdirectories recursively
		-f force: don't bitch at me. Just fucking do it.
		-v verbose: and give me a comprehensive report while you're at it.
	ls dir1 dir2 - apparently ls can list the contents of multiple directories at once
		-l long output (file size, date modified, permissions
		-a show hidden files
		-t sort the result by time modified
		--reverse reverses the order
		-S sort by file size (might be useful sometimes)
		-i show inode (unique memory address of each file)
	ln - create symbolic and hard links
	type - display the command's type that is about to be used
	which - displays the location of an executable.
	help - gives help for a shell builtin (there are only a few of these, such as cd)
	--help - running about any command with this directive will give options and use examples
	man - gives the manual of the executable you want to know about
		-k searches the entire set of manuals by search term
	info - similar to man, but also hyperlinked and provided from the GNU project
	whatis - gives an extremely brief description of the command
	alias - generates a new command out of a command sequence. For example, alias foo='cd /usr; ls;'
		- also with no arguments lists all the current system aliases.
	unalias - un-aliases a command created with alias
	sort - sorts plain text by alphanumeric order
	cmd



CHAPTER 1 INTRODUCTION
==========================
	* GUIs make easy tasks easy, and command lines make difficult tasks possible.

CHAPTER 2 - WHAT IS THE SHELL?
==================================
	* The command line is actually referring to the *shell*, a program that takes keyboard commands and passes them to the operating system to carry out. Most Linux distros use bash.

CHAPTER 3 - NAVIGATION 
=========================
	* directories are ordered in a hierachical structure as in windows
	* unlike windows, storage devices are mounted after the root directory, not in parallel with it.
	* this book is really cool because it's styled like a tutorial and is very linear - that might help to explain its rather absurd popularity. Excellent pedagogy.
	* by default the home directory is the only directory the user is allowed to write files
	* Most of the system's programs are installed in /usr/bin
	* Linux has no concept of file extensions (or not really). You can name files however you like. However, some programs do actually use file extensions.

CHAPTER 4 - EXPLORING THE SYSTEM
===================================
	* Apparently ls can list the contents of more than one directory. That's pretty damn cool.
	* commands are specified with options and arguments
	* 'long options' are specified with --double-dashes and are verbose, 'short options' are specified by a single character and a single dash such as -a. Short options can be combined together like ls -la
	* in the access rights field, a dash means a normal file and a d means a directory.
	* A common idea in unix operating systems is that "everything is a file"
	* Plain text generally refers to ASCII text.
	* 'less' is actually a program, or a command line utility used to view text. I think opening vim in read-only mode would be better
	* In Linux, there are no secrets. It's kind of a beautiful idea if I'm being honest. I hope it gains more traction in the future.
	* /bin mostly contains system binaries 
	* /boot contains the linux kernel
	* /dev contains *device nodes*, or all the devices that are plugged into the system. Everything is a file, remember.
	* /etc contains all the system-wide configuration files, and a collection of startup shell scripts.
	* /media is generally used for mounting devices on newer linux systems, while /mnt is used on older ones.
	* /sbin contains system binaries that perform vital tasks.
	* /usr contains all the programs and support files used by regular users, and largely mirrors the root directory.
	* programs compiled from source and installed after the fact are generally located in /usr/local/bin/
	* symbolic link is synonymous with soft link
	* symbolic links are used heavily for referencing software that needs to be updated and versioned

CHAPTER 5 - MANIPULATING FILES AND DIRECTORIES
================================================
	* avoid using [a-z] but instead just use [:lower:]. Same with [A-Z] and [:upper:]
	* apparently wildcards work in the GUI
	* 'nautilus' is the file manager for GNOME
	* mkdir can create multiple directories at once
	* cp can actually be used to copy multiple files at once into a directory. This is different than the typical functionality you are accustomed to.
	* Be careful with rm. Once you delete a file, it's gone forever (unless you were using source control! hahahaha)
	* accidentally typing rm * will delete all the files in the current directory.
	* Unix has the concept of hard links and symbolic links. Hard links cannot reference directories, and cannot reference files outside our current filesystem.
	* Hard links are indistinguishable from the file itself, it's a clone of the file. You can modify any of the hard links and they will all be updated.
	* Symbolic links are basically the same thing as windows shortcuts. Broken symbolic links are displayed in red with ls
	* Symbolic links will actually fuck up if you have two hard links in different locations of the same filename. They will be assigned to the one that's in the current directory lol.
	* Symbolic links can be made with absolute or relative pathnames, and these are maintained as the directories are moved around (so relative pathnames tend to be more robust, and they are *actually* different
	* File operations on the link are generally carried out on the underlying file itself.

CHAPTER 6 - WORKING WITH COMMANDS
===================================
	* What is a command really? Well, apparently it can be different things. Some are executable programs, or binaries. Some are commands built into the shell itself called "shell builtins". Some are shell functions, or miniature scripts, and some are aliases. We can figure out which is which.
	* type displays the command type 
	* which displays an executable's location
	* The 'which' command exists both to find location and to figure out which executable is actually being executed, because on large systems there may be more than one.
	* Square brackets indicate optional items, and vertical bars indicated mutually exclusive items.
	* Formal documentation for programs is contained in the "man" page of the program, and can be accessed with the "man" command.
	* Man pages generally contain a title, synopsis, description, and the options available. They generally don't include examples and are not intended as a tutorial, but a reference.
	* You can display a nextremely terse explanation of a command with "whatis"
	* We can create our own commands using 'alias'
	* commands can be separated on the same line with semicolons like so:
		command1; command2; command3; ...
	* alias foo='command text' can generate a new command with the name foo
	
CHAPTER 7 - REDIRECTION
==========================
	* I/O redirection is probably the coolest feature of the command line, and only poorly understood by myself.
	* the 'standard output' or *stdout* is actually considered a file, albiet a special one. The status messages go to another file called *standard error* or *stderr*. By default these are both sent to the screen and not to an actual file.
	* standard input, or *stdin* is by default attached to the keyboard
	* Apparently we can redirect the input, output, and error as we wish.
	* Redirecting standard output can be done using ">", or the redirection operator
	* Error messages are not sent to the standard output, they are sent to the standard error.
	* The redirection operator > always overwrites the file in question from the beginning
	* > test_file can actually just overwrite test_file with nothing, which is cool.
	* The >> redirection operator appends to a file instead of overwriting it from the beginning
	* Standard error is file descriptor number 2 using 2>
	* you can redirect both standard error and standard output using > file 2> err_file after the command
	* Redirecting both standard error and standard output to a single file you use &>. Otherwise you need to do > filename 2>&1
	* we can silence a command by redirecting the standard error to the "null file", which serves as a black hole for bits. just 2> /dev/null
	* /dev/null is called a "bit bucket" because it's literally just a bucket that holds bits.
	* cat reads a file and sends it to the standard output
	* this command is typically used for short source files (for obvious reasons)
	* it can be used on non-text file types as well, which can then be redirected to new files. 
	* if cat is not given any arguments, it reads from the standard input.
	* Ctrl-D gives an end-of-file signal to bash utilities
	* cat can basically be used as the world's dumbest word processor.
	* cat < filename is the same as cat filename, and it redirects the standard input to the filename
	* the pipe operator | sends standard output of one command to the standard input of the next command

